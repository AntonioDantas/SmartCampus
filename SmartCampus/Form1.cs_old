//using Accord.Neuro;
//using Accord.Neuro.Learning;
//using Accord.Statistics;
//using ArtificialNeuralNetwork;
//using ArtificialNeuralNetwork.Factories;
using Accord.Neuro;
using Accord.Neuro.Learning;
using GMap.NET;
using GMap.NET.MapProviders;
using GMap.NET.WindowsForms;
using GMap.NET.WindowsForms.Markers;
using SharpLearning.InputOutput.Csv;
using SharpLearning.Metrics.Regression;
using SharpLearning.Neural;
using SharpLearning.Neural.Activations;
using SharpLearning.Neural.Layers;
using SharpLearning.Neural.Learners;
using SharpLearning.Neural.Loss;
using SharpLearning.RandomForest.Learners;
using SmartCampus.Properties;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static SmartCampus.BackPropagation;

namespace SmartCampus
{
    public partial class Form1 : Form
    {
        public List<Dado> dados = new List<Dado>();
        public const int numInputs = 6;
        public const int numOutputs = 2;
        public string[] predios = { "IEST", "IMC", "IEPG", "ADM", "BIM" };
        public int[] quantidades = { 0, 0, 0, 0, 0 };
        public double[][] InputsTreino;
        public double[][] OutputTreino;
        public double[][] InputsTreinoNovo;
        public double[][] OutputTreinoNovo;
        public int sample = 0;


        public string treinamento = "D;A0;A1;A2;A3;A4;T\r\n";
        public string teste = "D;A0;A1;A2;A3;A4;T\r\n";

        public Form1()
        {
            InitializeComponent();

            StreamReader rd = new StreamReader(@"C:\Users\User\Desktop\Trabalho IA SmartCampus\client+ap_allData_20190610_121622_427.csv\client ap_allData_20190610_121622_427.csv");
            //StreamReader rd = new StreamReader(@"C:\Users\User\Desktop\Trabalho IA SmartCampus\debug.csv");
            string linha = null;
            string[] linhaseparada = null;
            linha = rd.ReadLine();
            while ((linha = rd.ReadLine()) != null)
            {
                try
                {
                    //linhaseparada = linha.Split(';');
                    linhaseparada = linha.Split(',');
                    string[] dt = linhaseparada[3].Split(' ');
                    string[] sd = linhaseparada[6].Replace("hrs", " ").Replace("min", " ").Replace("sec", "").Replace("  ", " ").Split(' ');

                    dados.Add(new Dado
                    {
                        //Tue May 21 19:12:14 BRT 2019
                        DataHora = Convert.ToDateTime($"{dt[2]}/{dt[1]}/{dt[5]} {dt[3]}"),
                        //1hrs15min 13sec
                        Duracao = new TimeSpan(Convert.ToInt32((sd.Count() == 2) ? "0" : sd[0]), Convert.ToInt32((sd.Count() == 2) ? sd[0] : sd[1]), Convert.ToInt32((sd.Count() == 2) ? sd[1] : sd[2])),
                        MacUsuario = linhaseparada[2],
                        Login = linhaseparada[0],
                        Local = linhaseparada[4]
                    });
                }
                catch { }
            }
            rd.Close();

            map.MapProvider = GMapProviders.GoogleMap;
            //map.DragButton = MouseButtons.Left;
            map.Position = new GMap.NET.PointLatLng(-22.4124616, -45.4492968);
            map.MaxZoom = 20;
            map.MinZoom = 5;
            map.Zoom = 17;

            //RedeNeural(DayOfWeek.Thursday,9);
            //RedesNeurais();
            //TestXOR();
            ObterDados("IMC");
            RegressionLearner_Learn_And_Predict();

            //Todos Prédios
            //for (var p = 0; p < predios.Count(); p++)
            //{
            //    //quantidades[p] = RegressionLearner_Learn_And_Predict(ObterDadosNovo(predios[p]), DateTime.Now.DayOfWeek.GetHashCode(), DateTime.Now.Hour);
            //    
            //}
            //initColorsBlocks();
            //Ver();


        }

        public byte Alpha = 0xff;
        public List<Color> ColorsOfMap = new List<Color>();

        private void initColorsBlocks()
        {
            ColorsOfMap.AddRange(new Color[]{
            //Color.FromArgb(Alpha, 0, 0, 0) ,//Black
            Color.FromArgb(Alpha, 0, 0, 0xFF) ,//Blue
            Color.FromArgb(Alpha, 0, 0xFF, 0xFF) ,//Cyan
            Color.FromArgb(Alpha, 0, 0xFF, 0) ,//Green
            Color.FromArgb(Alpha, 0xFF, 0xFF, 0) ,//Yellow
            Color.FromArgb(Alpha, 0xFF, 0, 0) ,//Red
            //Color.FromArgb(Alpha, 0xFF, 0xFF, 0xFF) // White
        });
        }


        public void RegressionLearner_Learn_And_Predict()
        {
            var parser = new CsvParser(() => new StringReader(treinamento));
            var targetName = "T";

            var observations = parser.EnumerateRows(c => c != targetName)
                .ToF64Matrix();
            var targets = parser.EnumerateRows(targetName)
                .ToF64Vector();
            var learner = new RegressionRandomForestLearner(trees: 100);
            var model = learner.Learn(observations, targets);

            parser = new CsvParser(() => new StringReader(teste));
            var observationsTeste = parser.EnumerateRows(c => c != targetName)
                .ToF64Matrix();
            var targetsTeste = parser.EnumerateRows(targetName)
                           .ToF64Vector();
                       
            // predict the training and test set.
            var trainPredictions = model.Predict(observations);
            var testPredictions = model.Predict(observationsTeste);

            // create the metric
            var metric = new MeanSquaredErrorRegressionMetric();

            // measure the error on training and test set.
            var trainError = metric.Error(targets, trainPredictions);
            var testError = metric.Error(targetsTeste, testPredictions);



            var net = new NeuralNet();
            net.Add(new InputLayer(7));
            net.Add(new DropoutLayer(0.2));
            net.Add(new DenseLayer(800, Activation.Relu));
            net.Add(new DropoutLayer(0.5));
            net.Add(new DenseLayer(800, Activation.Relu));
            net.Add(new DropoutLayer(0.5));
            net.Add(new SquaredErrorRegressionLayer());

            // using only 10 iteration to make the example run faster.
            // using square error as error metric. This is only used for reporting progress.
            var learnernet = new RegressionNeuralNetLearner(net, iterations: 10, loss: new SquareLoss());
            var modelnet = learner.Learn(observations, targets);

            var learnernetTeste = new RegressionNeuralNetLearner(net, loss: new LogLoss());
            var modelnetTeste = learner.Learn(observationsTeste, targetsTeste);

            trainPredictions = modelnet.Predict(observations);
            testPredictions = modelnetTeste.Predict(observationsTeste);

            var trainErrorNet = metric.Error(targets, trainPredictions);
            var testErrorNet = metric.Error(targetsTeste, testPredictions);
        }

        public string ObterDadosNovo(string predio)
        {
            string retorno = "dia_semana;hora;qtd\r\n";

            List<Dado> l = (from d in dados where d.Local.Contains(predio) select d).OrderBy(x => x.DataHora).ToList();
            try
            {
                for (var i = 1; i <= 31; i++)
                {
                    for (var j = 1; j < 24; j++)
                    {
                        try
                        {
                            retorno += $"{new DateTime(2019, l[0].DataHora.Month, i).DayOfWeek.GetHashCode()};{j};{(from x in l where x.DataHora.Day == i && x.DataHora.Hour >= j && j <= x.DataHora.Add(x.Duracao).Hour select x).Count()}\r\n";
                        }
                        catch
                        {

                        }
                    }
                }
            }
            catch (Exception err)
            {

            }
            return retorno;
        }

        public static Brush Rainbow(float progress)
        {
            float div = (Math.Abs(progress % 1) * 6);
            int ascending = (int)((div % 1) * 255);
            int descending = 255 - ascending;

            switch ((int)div)
            {
                case 0:
                    return new SolidBrush(Color.FromArgb(50, 255, ascending, 0));
                case 1:
                    return new SolidBrush(Color.FromArgb(50, descending, 255, 0));
                case 2:
                    return new SolidBrush(Color.FromArgb(50, 0, 255, ascending));
                case 3:
                    return new SolidBrush(Color.FromArgb(50, 0, descending, 255));
                case 4:
                    return new SolidBrush(Color.FromArgb(50, ascending, 0, 255));
                default: // case 5:
                    return new SolidBrush(Color.FromArgb(50, 255, 0, descending));
            }
        }

        public Brush GetColorForValue(double val, double maxVal)
        {
            double valPerc = val / maxVal;// value%
            double colorPerc = 1d / (ColorsOfMap.Count - 1);// % of each block of color. the last is the "100% Color"
            double blockOfColor = valPerc / colorPerc;// the integer part repersents how many block to skip
            int blockIdx = (int)Math.Truncate(blockOfColor);// Idx of 
            double valPercResidual = valPerc - (blockIdx * colorPerc);//remove the part represented of block 
            double percOfColor = valPercResidual / colorPerc;// % of color of this block that will be filled

            Color cTarget = ColorsOfMap[blockIdx];
            Color cNext = new Color();
            try
            {
                cNext = cNext = ColorsOfMap[blockIdx + 1];
            }
            catch
            {
                cNext = cNext = ColorsOfMap[blockIdx];
            }
            var deltaR = cNext.R - cTarget.R;
            var deltaG = cNext.G - cTarget.G;
            var deltaB = cNext.B - cTarget.B;

            var R = cTarget.R + (deltaR * percOfColor);
            var G = cTarget.G + (deltaG * percOfColor);
            var B = cTarget.B + (deltaB * percOfColor);

            Color c = ColorsOfMap[0];
            try
            {
                c = Color.FromArgb(Alpha, (byte)R, (byte)G, (byte)B);
            }
            catch (Exception ex)
            {
            }
            return new SolidBrush(c);
        }


        private void CriaRetangulo(List<PointLatLng> points, string nome, PointLatLng label, int qtd, int max)
        {
            if (qtd > 0)
            {
                GMapOverlay polyOverlay = new GMapOverlay("polygons");
                GMapPolygon polygon = new GMapPolygon(points, "mypolygon");
                polygon.Fill = GetColorForValue(qtd, max);
                polygon.Stroke = new Pen(Color.Black, 1);
                polyOverlay.Polygons.Add(polygon);
                polyOverlay.Markers.Add(new GMarkerCross(label) { ToolTipText = nome + ": " + qtd, IsVisible = true, ToolTipMode = MarkerTooltipMode.Always });
                map.Overlays.Add(polyOverlay);
            }
        }

        private void Ver()
        {
            map.Overlays.Clear();

            List<PointLatLng> points = new List<PointLatLng>();
            points.Add(new PointLatLng(-22.412097, -45.450659));
            points.Add(new PointLatLng(-22.411383, -45.450104));
            points.Add(new PointLatLng(-22.411936, -45.449243));
            points.Add(new PointLatLng(-22.412667, -45.449836));
            CriaRetangulo(points, "IEST", new PointLatLng(-22.412081, -45.450002), quantidades[0], quantidades.Max());

            points = new List<PointLatLng>();
            points.Add(new PointLatLng(-22.414410, -45.449176));
            points.Add(new PointLatLng(-22.413884, -45.448707));
            points.Add(new PointLatLng(-22.414244, -45.448074));
            points.Add(new PointLatLng(-22.414827, -45.448535));
            CriaRetangulo(points, "IMC", new PointLatLng(-22.414358, -45.448651), quantidades[1], quantidades.Max());

            points = new List<PointLatLng>();
            points.Add(new PointLatLng(-22.413944, -45.450194));
            points.Add(new PointLatLng(-22.413203, -45.449615));
            points.Add(new PointLatLng(-22.413587, -45.449051));
            points.Add(new PointLatLng(-22.414291, -45.449641));
            CriaRetangulo(points, "IEPG", new PointLatLng(-22.413830, -45.449593), quantidades[2], quantidades.Max());

            points = new List<PointLatLng>();
            points.Add(new PointLatLng(-22.413215, -45.450666));
            points.Add(new PointLatLng(-22.412920, -45.450427));
            points.Add(new PointLatLng(-22.413173, -45.449968));
            points.Add(new PointLatLng(-22.413438, -45.450186));
            CriaRetangulo(points, "ADM", new PointLatLng(-22.413210, -45.450381), quantidades[3], quantidades.Max());

            points = new List<PointLatLng>();
            points.Add(new PointLatLng(-22.412962, -45.449166));
            points.Add(new PointLatLng(-22.412560, -45.448871));
            points.Add(new PointLatLng(-22.412893, -45.448318));
            points.Add(new PointLatLng(-22.413344, -45.448683));
            CriaRetangulo(points, "BIM", new PointLatLng(-22.412982, -45.448726), quantidades[4], quantidades.Max());
        }

        private void PictureBox1_Click(object sender, EventArgs e)
        {

        }

        public async void ObterDados(string predio)
        {

            treinamento = "D;A0;A1;A2;A3;A4;T\r\n";
            teste = "D;A0;A1;A2;A3;A4;T\r\n";

            List<Dado> l = (from d in dados where d.Local.Contains(predio) select d).OrderBy(x => x.DataHora).ToList();
            try
            {
                for (var m = 5; m <= 6; m++)
                {
                    List < Dado > mes = (from d in l where d.DataHora.Month == m select d).OrderBy(x => x.DataHora).ToList();
                    for (var i = 1; i <= 31 && mes.Count > 0; i++)
                    {
                        List<Dado> temp = (from d in mes where d.DataHora.Day == i select d).OrderBy(x => x.DataHora).ToList();
                        for (var j = 5; j < 24 && temp.Count > 0; j++)
                        {
                            try
                            {
                                string linha = $"{new DateTime(2019, m, i).DayOfWeek.GetHashCode()};";
                                for (var k = j - 5; k <= j; k++)
                                {
                                    linha += $"{(from x in temp where x.DataHora.Hour >= k && k <= x.DataHora.Add(x.Duracao).Hour select x.MacUsuario).Distinct().Count()};";
                                }

                                linha = linha.Substring(0, linha.Length - 1) + "\r\n";
                                
                                if (!linha.Contains(";0;0;0;0;0"))
                                {
                                    if (new DateTime(2019, m, i) < new DateTime(2019, 6, 10))
                                    {
                                        treinamento += linha;
                                    }
                                    else
                                    {
                                        teste += linha;
                                    }
                                }
                            }
                            catch
                            {

                            }
                        }
                    }
                }
            }
            catch (Exception err)
            {

            }

            treinamento = treinamento.Substring(0, treinamento.Length - 2);
            teste = teste.Substring(0, teste.Length - 2);

        }

        //        public void TestXOR()
        //        {
        //            // initialize input and output values
        //            double[][] input =
        //            {
        //    new double[] {0, 0}, new double[] {0, 1},
        //    new double[] {1, 0}, new double[] {1, 1}
        //};

        //            double[][] output =
        //            {
        //    new double[] {0}, new double[] {1},
        //    new double[] {1}, new double[] {0}
        //};

        //            // create neural network
        //            ActivationNetwork network = new ActivationNetwork(
        //                new SigmoidFunction(2),
        //                2, // two inputs in the network
        //                2, // two neurons in the first layer
        //                1); // one neuron in the second layer

        //            // create teacher
        //            var teacher = new ResilientBackpropagationLearning(network);

        //            // loop
        //            while (true)
        //            {
        //                // run epoch of learning procedure
        //                double error = teacher.RunEpoch(input, output);
        //                // check error value to see if we need to stop
        //                // ...
        //            }

        //        }

        //public void RedesNeurais()
        //{
        //
        //    // create multi-layer neural network
        //    //ActivationNetwork network = new ActivationNetwork( new BipolarSigmoidFunction(2.0), 6, 6 * 2, 1);
        //    ActivationNetwork network = new ActivationNetwork(new BipolarSigmoidFunction(2.0), 2, 2 * 2, 1);
        //
        //    // create teacher
        //    LevenbergMarquardtLearning teacher = new LevenbergMarquardtLearning(network, false);
        //
        //    // set learning rate
        //    teacher.LearningRate = 0.1;
        //
        //    // iterations
        //    int iteration = 1;
        //
        //    // solution array
        //    //int solutionSize = sample - 5;
        //    //double[,] solution = new double[solutionSize, 2];
        //    //double[] networkInput = new double[5];
        //    //
        //    //// calculate X values to be used with solution function
        //    //for (int j = 0; j < solutionSize; j++)
        //    //{
        //    //    solution[j, 0] = j + 5;
        //    //}
        //    for (int j = 0; j < sample; j++)
        //    {
        //        //Console.WriteLine($"[{InputsTreino[j][0]},{InputsTreino[j][1]},{InputsTreino[j][2]},{InputsTreino[j][3]},{InputsTreino[j][4]},{InputsTreino[j][5]}],");
        //        Console.WriteLine($"[{InputsTreinoNovo[j][0]},{InputsTreinoNovo[j][1]}],");
        //    }
        //
        //    for (int j = 0; j < sample; j++)
        //    {
        //        Console.WriteLine($"[{OutputTreinoNovo[j][0]}],");
        //    }
        //
        //    bool needToStop = false;
        //    int iterations = 0;
        //    // loop
        //    while (!needToStop)
        //    {
        //        // run epoch of learning procedure
        //        double error = teacher.RunEpoch(InputsTreinoNovo, OutputTreinoNovo) / sample;
        //
        //        // increase current iteration
        //        iteration++;
        //
        //        // check if we need to stop
        //        if ((iteration != 0) && (iteration > 10000))
        //            break;
        //    }
        //
        //    double y = (network..Compute(InputsTreinoNovo[15])[0]);
        //    double x = (network.Compute(InputsTreinoNovo[15])[0] + 1) * 333;
        //
        //}

        //public void RedesNeuraisAntiga()
        //{
        //    // Create an activation function for the net
        //    // create neural network
        //    ActivationNetwork network = new ActivationNetwork(
        //        new SigmoidFunction(2),
        //        6, // inputs in the network
        //        6, // neurons in the first layer
        //        1); // one neuron in the second layer
        //
        //    // create teacher
        //    var teacher = new ResilientBackpropagationLearning(network);
        //
        //    // loop
        //    int vezes = 0;
        //    while (vezes++ < 2000)
        //    {
        //        teacher.RunEpoch(InputsTreino, OutputTreino);
        //    }
        //
        //    vezes = 0;
        //    double[] answer = new double[] { 1 };
        //    while (answer[0] >= 0 && answer[0] <= 1)
        //        answer = network.Compute(InputsTreino[vezes++]);
        //
        //    string teste = answer[0].ToString();
        //
        //    //Neuron hiddenNeuron1 = new Neuron();
        //    //Neuron hiddenNeuron2 = new Neuron();
        //    //Neuron outputNeuron = new Neuron();
        //    //
        //    //// random weights
        //    //hiddenNeuron1.randomizeWeights();
        //    //hiddenNeuron2.randomizeWeights();
        //    //outputNeuron.randomizeWeights();
        //    //
        //    //int epoch = 0;
        //    //
        //    //Retry:
        //    //epoch++;
        //    //for (int i = 0; i < nulo; i++)  // very important, do NOT train for only one example
        //    //{
        //    //    // 1) forward propagation (calculates output)
        //    //    hiddenNeuron1.inputs = new double[] { InputsTreino[i][0], InputsTreino[i][1], InputsTreino[i][2], InputsTreino[i][3], InputsTreino[i][4], InputsTreino[i][5] };
        //    //    hiddenNeuron2.inputs = new double[] { InputsTreino[i][0], InputsTreino[i][1], InputsTreino[i][2], InputsTreino[i][3], InputsTreino[i][4], InputsTreino[i][5] };
        //    //
        //    //    outputNeuron.inputs = new double[] { hiddenNeuron1.output, hiddenNeuron2.output };
        //    //                           
        //    //    outputNeuron.error = sigmoid.derivative(outputNeuron.output) * (OutputTreino[i][0] - outputNeuron.output);
        //    //    outputNeuron.adjustWeights();
        //    //
        //    //    // then adjusts the hidden neurons' weights, based on their errors
        //    //    hiddenNeuron1.error = sigmoid.derivative(hiddenNeuron1.output) * outputNeuron.error * outputNeuron.weights[0];
        //    //    hiddenNeuron2.error = sigmoid.derivative(hiddenNeuron2.output) * outputNeuron.error * outputNeuron.weights[1];
        //    //
        //    //    hiddenNeuron1.adjustWeights();
        //    //    hiddenNeuron2.adjustWeights();
        //    //}
        //    //
        //    //if (epoch < 2000)
        //    //    goto Retry;
        //    //
        //    //hiddenNeuron1.inputs = new double[] { 1 , 5, 4, 3, 2, 1 };
        //    //outputNeuron.inputs = new double[] { hiddenNeuron1.output };
        //
        //}

        //public void RedeNeural(DayOfWeek DiaSemana, int Hora)
        //{
        //    List<Dado> DadosFiltrados = (from d in dados
        //                                 where d.DataHora.DayOfWeek == DiaSemana
        //                                 select d).ToList();
        //    var numHiddenLayers = 1;
        //    var numNeuronsInHiddenLayer = 5;
        //    INeuralNetwork network = null;

        //    int[] qtds = { 0, 0, 0, 0, 0 };
        //    int soma = 0;

        //    for (int i = 0; i < predios.Count(); i++)
        //    {
        //        network = NeuralNetworkFactory.GetInstance().Create(numInputs, numOutputs, numHiddenLayers, numNeuronsInHiddenLayer);
        //        var dadosPredios = (from d in DadosFiltrados where d.Local.Contains(predios[i]) select d).OrderBy(x => x.DataHora).ToList();
        //        double[] inputs = new double[numInputs];
        //        DateTime dtAtual = dadosPredios[0].DataHora;
        //        for (var j = 0; j < dadosPredios.Count(); j++)
        //        {
        //            if (dtAtual.Day != dadosPredios[j].DataHora.Day || j == dadosPredios.Count() - 1)
        //            {
        //                //inputs[24] = inputs[Hora];
        //                //inputs[Hora] = 0;
        //                //for (var z = 0; z < 25; z++)
        //                //    inputs[z] = (inputs[z] / 10);
        //                network.SetInputs(inputs);

        //                inputs = new double[numInputs];
        //                dtAtual = dadosPredios[j].DataHora;
        //            }
        //            inputs[dadosPredios[j].DataHora.Hour]++;
        //        }
        //        network.Process();
        //        var outputs = network.GetOutputs();
        //        qtds[i] = (int)(outputs[0] * 10);
        //        soma += qtds[i];
        //    }

        //    //map.Overlays.Clear();

        //    List<PointLatLng> points = new List<PointLatLng>();
        //    points.Add(new PointLatLng(-22.412097, -45.450659));
        //    points.Add(new PointLatLng(-22.411383, -45.450104));
        //    points.Add(new PointLatLng(-22.411936, -45.449243));
        //    points.Add(new PointLatLng(-22.412667, -45.449836));
        //    CriaRetangulo(points, "EST", new PointLatLng(-22.412081, -45.450002), qtds[0], soma);

        //    points = new List<PointLatLng>();
        //    points.Add(new PointLatLng(-22.414410, -45.449176));
        //    points.Add(new PointLatLng(-22.413884, -45.448707));
        //    points.Add(new PointLatLng(-22.414244, -45.448074));
        //    points.Add(new PointLatLng(-22.414827, -45.448535));
        //    CriaRetangulo(points, "IMC", new PointLatLng(-22.414358, -45.448651), qtds[1], soma);

        //    points = new List<PointLatLng>();
        //    points.Add(new PointLatLng(-22.413944, -45.450194));
        //    points.Add(new PointLatLng(-22.413203, -45.449615));
        //    points.Add(new PointLatLng(-22.413587, -45.449051));
        //    points.Add(new PointLatLng(-22.414291, -45.449641));
        //    CriaRetangulo(points, "IEPG", new PointLatLng(-22.413830, -45.449593), qtds[2], soma);

        //    points = new List<PointLatLng>();
        //    points.Add(new PointLatLng(-22.413215, -45.450666));
        //    points.Add(new PointLatLng(-22.412920, -45.450427));
        //    points.Add(new PointLatLng(-22.413173, -45.449968));
        //    points.Add(new PointLatLng(-22.413438, -45.450186));
        //    CriaRetangulo(points, "ADM", new PointLatLng(-22.413210, -45.450381), qtds[3], soma);

        //    points = new List<PointLatLng>();
        //    points.Add(new PointLatLng(-22.412962, -45.449166));
        //    points.Add(new PointLatLng(-22.412560, -45.448871));
        //    points.Add(new PointLatLng(-22.412893, -45.448318));
        //    points.Add(new PointLatLng(-22.413344, -45.448683));
        //    CriaRetangulo(points, "BIM", new PointLatLng(-22.412982, -45.448726), qtds[4], soma);
        //}
    }
}
